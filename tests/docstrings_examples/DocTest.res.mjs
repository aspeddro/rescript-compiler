// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Os from "os";
import * as Url from "url";
import * as List from "rescript/lib/es6/List.js";
import * as Path from "path";
import * as $$Array from "rescript/lib/es6/Array.js";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Child_process from "child_process";
import * as Promises from "node:fs/promises";
import * as RescriptTools_Docgen from "rescript/lib/es6/RescriptTools_Docgen.js";

let Path$1 = {};

let URL = {};

let Process = {};

let Fs$1 = {};

let Buffer = {};

let ChildProcess = {};

let OS = {};

let Node = {
  Path: Path$1,
  URL: URL,
  Process: Process,
  Fs: Fs$1,
  Buffer: Buffer,
  ChildProcess: ChildProcess,
  OS: OS
};

let dirname = Path.dirname(Url.fileURLToPath(import.meta.url));

let compilerDir = Path.join(dirname, "..", ".examples-tests");

let rescriptBin = Path.join(compilerDir, "node_modules", ".bin", "rescript");

let bscBin = Path.join("cli", "bsc");

let rescriptCoreCompiled = Path.join(compilerDir, "node_modules", "@rescript", "core", "lib", "ocaml");

function makePackageJson(coreVersion) {
  return "{\n  \"name\": \"test-compiler-examples\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@rescript/core\": \"file:rescript-core-" + coreVersion + ".tgz\",\n    \"rescript\": \"11.1.4\"\n  }\n}\n";
}

let rescriptJson = "{\n  \"name\": \"dummy\",\n  \"sources\": {\n    \"dir\": \"dummy\",\n    \"subdirs\": true\n  },\n  \"bs-dependencies\": [\n    \"@rescript/core\"\n  ],\n  \"bsc-flags\": [\n    \"-open RescriptCore\"\n  ]\n}";

function prepareCompiler() {
  let corePath = Path.join(compilerDir, "..");
  if (!Fs.existsSync(compilerDir)) {
    Fs.mkdirSync(compilerDir);
  }
  Child_process.execFileSync("npm", [
    "pack",
    corePath
  ], {
    stdio: "ignore",
    cwd: compilerDir
  });
  let dict = JSON.parse(Fs.readFileSync(Path.join(corePath, "package.json")));
  let currentCoreVersion;
  if (typeof dict === "object" && !Array.isArray(dict)) {
    let s = dict["version"];
    if (typeof s === "string") {
      currentCoreVersion = s;
    } else {
      throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "DocTest.res",
          127,
          11
        ],
        Error: new Error()
      };
    }
  } else {
    throw {
      RE_EXN_ID: "Assert_failure",
      _1: [
        "DocTest.res",
        129,
        9
      ],
      Error: new Error()
    };
  }
  Fs.writeFileSync(Path.join(compilerDir, "package.json"), makePackageJson(currentCoreVersion));
  Fs.writeFileSync(Path.join(compilerDir, "rescript.json"), rescriptJson);
  let dummyFolder = Path.join(compilerDir, "dummy");
  if (!Fs.existsSync(dummyFolder)) {
    Fs.mkdirSync(dummyFolder);
  }
  Child_process.execFileSync("npm", ["install"], {
    cwd: compilerDir
  });
  Child_process.execFileSync(rescriptBin, ["build"], {
    cwd: compilerDir
  });
}

function createFileInTempDir(id) {
  return Path.join(Os.tmpdir(), id);
}

async function testCode(id, code) {
  let id$1 = id.includes("/") ? id.replace("/", "slash_op") : id;
  let tempFileName = Path.join(Os.tmpdir(), id$1);
  await Promises.writeFile(tempFileName + ".res", code);
  let args = [
    tempFileName + ".res",
    "-I",
    rescriptCoreCompiled,
    "-w",
    "-3-109"
  ];
  let promise = await new Promise((resolve, _reject) => {
    let spawn = Child_process.spawn(bscBin, args);
    let stderr = [];
    spawn.stderr.on("data", data => {
      stderr.push(data);
    });
    spawn.once("close", (_code, _signal) => resolve(stderr));
  });
  if (promise.length > 0) {
    return {
      TAG: "Error",
      _0: promise.map(e => e.toString()).join("")
    };
  } else {
    return {
      TAG: "Ok",
      _0: undefined
    };
  }
}

function extractDocFromFile(file) {
  let toolsBin = Path.join(process.cwd(), "cli", "rescript-tools");
  let spawn = Child_process.spawnSync(toolsBin, [
    "doc",
    file
  ]);
  return RescriptTools_Docgen.decodeFromJson(JSON.parse(spawn.stdout.toString()));
}

function getExamples(param) {
  let loop = (_items, _acc) => {
    while (true) {
      let acc = _acc;
      let items = _items;
      if (!items) {
        return acc;
      }
      let match = items.hd;
      switch (match.kind) {
        case "value" :
          _acc = {
            hd: {
              id: match.id,
              kind: "value",
              name: match.name,
              docstrings: match.docstrings
            },
            tl: acc
          };
          _items = items.tl;
          continue;
        case "type" :
          _acc = {
            hd: {
              id: match.id,
              kind: "type",
              name: match.name,
              docstrings: match.docstrings
            },
            tl: acc
          };
          _items = items.tl;
          continue;
        case "module" :
          _acc = {
            hd: {
              id: match.id,
              kind: "module",
              name: match.name,
              docstrings: match.docstrings
            },
            tl: acc
          };
          _items = Belt_List.concatMany([
            items.tl,
            List.fromArray(match.items)
          ]);
          continue;
        case "moduleType" :
          _acc = {
            hd: {
              id: match.id,
              kind: "moduleType",
              name: match.name,
              docstrings: match.docstrings
            },
            tl: acc
          };
          _items = Belt_List.concatMany([
            items.tl,
            List.fromArray(match.items)
          ]);
          continue;
        case "moduleAlias" :
          _acc = {
            hd: {
              id: match.id,
              kind: "moduleAlias",
              name: match.name,
              docstrings: match.docstrings
            },
            tl: acc
          };
          _items = Belt_List.concatMany([
            items.tl,
            List.fromArray(match.items)
          ]);
          continue;
      }
    };
  };
  return List.toArray(loop(List.fromArray(param.items), /* [] */0)).filter(param => param.docstrings.length > 0);
}

function getCodeBlocks(example) {
  let loopEndCodeBlock = (_lines, _acc) => {
    while (true) {
      let acc = _acc;
      let lines = _lines;
      if (!lines) {
        return Pervasives.panic("Failed to find end of code block for " + example.kind + ": " + example.id);
      }
      let hd = lines.hd;
      if (hd.trim().endsWith("```")) {
        return acc;
      }
      _acc = {
        hd: hd,
        tl: acc
      };
      _lines = lines.tl;
      continue;
    };
  };
  let loop = (_lines, _acc) => {
    while (true) {
      let acc = _acc;
      let lines = _lines;
      if (!lines) {
        return acc;
      }
      let rest = lines.tl;
      if (lines.hd.trim().startsWith("```res")) {
        let code = loopEndCodeBlock(rest, /* [] */0);
        _acc = {
          hd: List.toArray(List.reverse(code)).join("\n"),
          tl: acc
        };
        _lines = rest;
        continue;
      }
      _lines = rest;
      continue;
    };
  };
  return List.toArray(loop(List.fromArray($$Array.reduce(example.docstrings, [], (acc, docstring) => acc.concat(docstring.split("\n")))), /* [] */0));
}

async function main() {
  let modules = Fs.readdirSync("runtime").filter(f => {
    if (f.endsWith(".resi")) {
      return !f.startsWith("Belt");
    } else {
      return false;
    }
  }).map(f => getExamples(extractDocFromFile(Path.join("runtime", f)))).flat();
  let results = await Promise.all(modules.map(async example => {
    let id = example.id.replaceAll(".", "_");
    let codes = getCodeBlocks(example);
    let results = await Promise.all(codes.map(async (code, int) => {
      let id$1 = id + "_" + int.toString();
      return await testCode(id$1, code);
    }));
    return [
      example,
      results
    ];
  }));
  let errors = Belt_Array.keepMap(results, param => {
    let errors = Belt_Array.keepMap(param[1], result => {
      if (result.TAG === "Ok") {
        return;
      } else {
        return result._0;
      }
    });
    if (errors.length > 0) {
      return [
        param[0],
        errors
      ];
    }
    
  });
  errors.forEach(param => {
    let test = param[0];
    let cyan = s => "\x1b[36m" + s + "\x1b[0m";
    let other = test.kind;
    let kind = other === "moduleAlias" ? "module alias" : other;
    let errorMessage = param[1].map(e => e.split("\n").filter((param, i) => i !== 2).join("\n")).join("\n");
    let message = "\x1B[1;31merror\x1B[0m: failed to compile examples from " + kind + " " + cyan(test.id) + "\n" + errorMessage;
    process.stderr.write(message);
  });
  if (errors.length === 0) {
    return 0;
  } else {
    return 1;
  }
}

let exitCode = await main();

process.exit(exitCode);

let Docgen;

export {
  Node,
  Docgen,
  dirname,
  compilerDir,
  rescriptBin,
  bscBin,
  rescriptCoreCompiled,
  makePackageJson,
  rescriptJson,
  prepareCompiler,
  createFileInTempDir,
  testCode,
  extractDocFromFile,
  getExamples,
  getCodeBlocks,
  main,
  exitCode,
}
/* dirname Not a pure module */
